/* Circle.vala.c generated by valac 0.56.17, the Vala compiler
 * generated from Circle.vala, do not modify */

/* src/Circle.vala*/

#include <glib-object.h>
#include <glib.h>
#include <float.h>
#include <math.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif
#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define TYPE_SHAPE (shape_get_type ())
#define SHAPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SHAPE, Shape))
#define SHAPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SHAPE, ShapeClass))
#define IS_SHAPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SHAPE))
#define IS_SHAPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SHAPE))
#define SHAPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SHAPE, ShapeClass))

typedef struct _Shape Shape;
typedef struct _ShapeClass ShapeClass;
typedef struct _ShapePrivate ShapePrivate;

#define TYPE_CIRCLE (circle_get_type ())
#define CIRCLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CIRCLE, Circle))
#define CIRCLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CIRCLE, CircleClass))
#define IS_CIRCLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CIRCLE))
#define IS_CIRCLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CIRCLE))
#define CIRCLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CIRCLE, CircleClass))

typedef struct _Circle Circle;
typedef struct _CircleClass CircleClass;
typedef struct _CirclePrivate CirclePrivate;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _Shape {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ShapePrivate * priv;
};

struct _ShapeClass {
	GTypeClass parent_class;
	void (*finalize) (Shape *self);
	gdouble (*get_area) (Shape* self);
	gdouble (*get_area_less_than_50000) (Shape* self);
	void (*move) (Shape* self, gint delta_x, gint delta_y);
};

struct _Circle {
	Shape parent_instance;
	CirclePrivate * priv;
};

struct _CircleClass {
	ShapeClass parent_class;
};

struct _CirclePrivate {
	gdouble radius;
};

static gint Circle_private_offset;
static gpointer circle_parent_class = NULL;

VALA_EXTERN gpointer shape_ref (gpointer instance);
VALA_EXTERN void shape_unref (gpointer instance);
VALA_EXTERN GParamSpec* param_spec_shape (const gchar* name,
                              const gchar* nick,
                              const gchar* blurb,
                              GType object_type,
                              GParamFlags flags);
VALA_EXTERN void value_set_shape (GValue* value,
                      gpointer v_object);
VALA_EXTERN void value_take_shape (GValue* value,
                       gpointer v_object);
VALA_EXTERN gpointer value_get_shape (const GValue* value);
VALA_EXTERN GType shape_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Shape, shape_unref)
VALA_EXTERN GType circle_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Circle, shape_unref)
VALA_EXTERN gdouble shape_get_area (Shape* self);
VALA_EXTERN gdouble shape_get_area_less_than_50000 (Shape* self);
VALA_EXTERN Circle* circle_new (gdouble radius);
VALA_EXTERN Circle* circle_construct (GType object_type,
                          gdouble radius);
VALA_EXTERN Shape* shape_construct (GType object_type);
VALA_EXTERN void circle_set_radius (Circle* self,
                        gdouble new_radius);
static gdouble circle_real_get_area (Shape* base);
static gdouble circle_real_get_area_less_than_50000 (Shape* base);
static void circle_finalize (Shape * obj);
static GType circle_get_type_once (void);

static inline gpointer
circle_get_instance_private (Circle* self)
{
	return G_STRUCT_MEMBER_P (self, Circle_private_offset);
}

Circle*
circle_construct (GType object_type,
                  gdouble radius)
{
	Circle* self = NULL;
	_vala_return_val_if_fail (radius > 0.0, "radius > 0.0", NULL);
	self = (Circle*) shape_construct (object_type);
	self->priv->radius = radius;
	_vala_warn_if_fail (self->priv->radius == radius, "this.radius == radius");
	return self;
}

Circle*
circle_new (gdouble radius)
{
	return circle_construct (TYPE_CIRCLE, radius);
}

void
circle_set_radius (Circle* self,
                   gdouble new_radius)
{
	g_return_if_fail (self != NULL);
	_vala_return_if_fail (new_radius > 0.0, "new_radius > 0.0");
	self->priv->radius = new_radius;
	_vala_warn_if_fail (self->priv->radius == new_radius, "this.radius == new_radius");
}

static gdouble
circle_real_get_area (Shape* base)
{
	Circle * self;
	gdouble result;
	self = (Circle*) base;
	result = (G_PI * self->priv->radius) * self->priv->radius;
	return result;
}

static gdouble
circle_real_get_area_less_than_50000 (Shape* base)
{
	Circle * self;
	gdouble result;
	self = (Circle*) base;
	result = (G_PI * self->priv->radius) * self->priv->radius;
	_vala_warn_if_fail ((result >= 0.0) && (result <= 50000.0), "result >= 0.0 && result <= 50000.0");
	return result;
}

static void
circle_class_init (CircleClass * klass,
                   gpointer klass_data)
{
	circle_parent_class = g_type_class_peek_parent (klass);
	((ShapeClass *) klass)->finalize = circle_finalize;
	g_type_class_adjust_private_offset (klass, &Circle_private_offset);
	((ShapeClass *) klass)->get_area = (gdouble (*) (Shape*)) circle_real_get_area;
	((ShapeClass *) klass)->get_area_less_than_50000 = (gdouble (*) (Shape*)) circle_real_get_area_less_than_50000;
}

static void
circle_instance_init (Circle * self,
                      gpointer klass)
{
	self->priv = circle_get_instance_private (self);
}

static void
circle_finalize (Shape * obj)
{
	Circle * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CIRCLE, Circle);
	SHAPE_CLASS (circle_parent_class)->finalize (obj);
}

static GType
circle_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (CircleClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) circle_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Circle), 0, (GInstanceInitFunc) circle_instance_init, NULL };
	GType circle_type_id;
	circle_type_id = g_type_register_static (TYPE_SHAPE, "Circle", &g_define_type_info, 0);
	Circle_private_offset = g_type_add_instance_private (circle_type_id, sizeof (CirclePrivate));
	return circle_type_id;
}

GType
circle_get_type (void)
{
	static volatile gsize circle_type_id__once = 0;
	if (g_once_init_enter (&circle_type_id__once)) {
		GType circle_type_id;
		circle_type_id = circle_get_type_once ();
		g_once_init_leave (&circle_type_id__once, circle_type_id);
	}
	return circle_type_id__once;
}

